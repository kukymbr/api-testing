package js

import (
	"errors"
	"fmt"
	"strconv"
	"strings"
	"unicode"
)

var ErrInvalidPath = errors.New("invalid path")

// PathElement is a part of the Path.
type PathElement interface {
	// IsIndex can be used to determine whether an element is a string (property name) or
	// an index array.
	IsIndex() bool
	fmt.Stringer
}

// PropertyName holds up property name value under Path.
type PropertyName string

// IsIndex on PropertyName always returns false.
func (p PropertyName) IsIndex() bool {
	return false
}

// String returns property name as is.
func (p PropertyName) String() string {
	return string(p)
}

// ArrayIndex holds up array index value under Path.
type ArrayIndex int

// IsIndex on ArrayIndex always returns true.
func (a ArrayIndex) IsIndex() bool {
	return true
}

// String returns array index values converted into a string.
func (a ArrayIndex) String() string {
	return strconv.Itoa(int(a))
}

// Path is generated by the validator and indicates how it reached the invalid value
// from the root element. Property path is denoted by dots, while array access
// is denoted by square brackets. For example, "book.keywords[0]" means that the violation
// occurred on the first element of array "keywords" in the "book" object.
//
// Internally Path is a linked list. You can create a new path using WithProperty
// or WithIndex methods. Path should always be used as a pointer value.
// Nil value is a valid value that means that the property path is empty.
type Path struct {
	parent *Path
	value  PathElement
}

// NewPath creates a Path from the list of elements. If the list is empty nil will be returned.
// Nil value is a valid value that means that the property path is empty.
func NewPath(elements ...PathElement) *Path {
	var path *Path

	for _, element := range elements {
		path = &Path{parent: path, value: element}
	}

	return path
}

//nolint:cyclop
func PathFromAny(elements ...interface{}) (*Path, error) {
	var path *Path

	for _, element := range elements {
		switch v := element.(type) {
		case string:
			path = path.WithProperty(v)
		case fmt.Stringer:
			path = path.WithProperty(v.String())
		case int:
			path = path.WithIndex(v)
		case int8:
			path = path.WithIndex(int(v))
		case int16:
			path = path.WithIndex(int(v))
		case int32:
			path = path.WithIndex(int(v))
		case int64:
			path = path.WithIndex(int(v))
		case uint8:
			path = path.WithIndex(int(v))
		case uint16:
			path = path.WithIndex(int(v))
		case uint32:
			path = path.WithIndex(int(v))
		case uint64:
			path = path.WithIndex(int(v))
		case uint:
			path = path.WithIndex(int(v))
		default:
			return nil, fmt.Errorf("%w: should contain only strings and numbers", ErrInvalidPath)
		}
	}

	return path, nil
}

// With returns new Path with appended elements to the end of the list.
func (path *Path) With(next *Path) *Path {
	p := path
	for _, element := range next.Elements() {
		p = &Path{parent: p, value: element}
	}
	return p
}

// WithProperty returns new Path with appended PropertyName to the end of the list.
func (path *Path) WithProperty(name string) *Path {
	return &Path{
		parent: path,
		value:  PropertyName(name),
	}
}

// WithIndex returns new Path with appended ArrayIndex to the end of the list.
func (path *Path) WithIndex(index int) *Path {
	return &Path{
		parent: path,
		value:  ArrayIndex(index),
	}
}

// Elements returns property path as a slice of PathElement.
// It returns nil if property path is nil (empty).
func (path *Path) Elements() []PathElement {
	if path == nil || path.value == nil {
		return nil
	}

	length := path.Len()
	elements := make([]PathElement, length)

	i := length - 1
	element := path
	for element != nil {
		elements[i] = element.value
		element = element.parent
		i--
	}

	return elements
}

// Len returns count of property path elements.
func (path *Path) Len() int {
	length := 0
	element := path
	for element != nil {
		length++
		element = element.parent
	}
	return length
}

// String is used to format property path to a string.
func (path *Path) String() string {
	elements := path.Elements()
	count := 0
	for _, element := range elements {
		if s, ok := element.(PropertyName); ok {
			count += len(s)
		} else {
			count += 2
		}
	}

	s := strings.Builder{}
	s.Grow(count)
	for i, element := range elements {
		name := element.String()
		//nolint:gocritic
		if element.IsIndex() {
			s.WriteString("[" + name + "]")
		} else if isIdentifier(name) {
			if i > 0 {
				s.WriteString(".")
			}
			s.WriteString(name)
		} else {
			s.WriteString("['")
			writePropertyName(&s, name)
			s.WriteString("']")
		}
	}

	return s.String()
}

// MarshalText will marshal property path value to a string.
func (path *Path) MarshalText() (text []byte, err error) {
	return []byte(path.String()), nil
}

func isIdentifier(s string) bool {
	if len(s) == 0 {
		return false
	}
	for i, c := range s {
		if i == 0 && !isFirstIdentifierChar(c) {
			return false
		}
		if i > 0 && !isIdentifierChar(c) {
			return false
		}
	}

	return true
}

func isFirstIdentifierChar(c rune) bool {
	return unicode.IsLetter(c) || c == '$' || c == '_'
}

func isIdentifierChar(c rune) bool {
	return unicode.IsLetter(c) || unicode.IsDigit(c) || c == '$' || c == '_'
}

func writePropertyName(s *strings.Builder, name string) {
	for _, c := range name {
		if c == '\'' || c == '\\' {
			s.WriteRune('\\')
		}
		s.WriteRune(c)
	}
}
